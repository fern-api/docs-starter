---
layout: overview
slug: ttl/ttl/_src/auto_profile
title: ttl._src.auto_profile
---

Auto-profiling infrastructure for tt-lang kernels.

Enabled via TTLANG_AUTO_PROFILE=1 environment variable.
Automatically instruments every operation with signposts and generates
a visual profile report showing cycle counts per source line.

## Module Contents

### Classes

| Name | Description |
|------|-------------|
| [`Colors`](#ttl-_src-auto_profile-Colors) | ANSI color codes for terminal output. |
| [`ProfileResult`](#ttl-_src-auto_profile-ProfileResult) | Represents profiling results for a single signpost. |
| [`SourceLineMapper`](#ttl-_src-auto_profile-SourceLineMapper) | Maps signpost markers back to source code lines. |

### Functions

| Name | Description |
|------|-------------|
| [`build_cb_wait_to_dma_map`](#ttl-_src-auto_profile-build_cb_wait_to_dma_map) | Build mapping from cb_wait locations to DMA barrier locations. |
| [`build_dma_producer_to_cb_map`](#ttl-_src-auto_profile-build_dma_producer_to_cb_map) | Build mapping from DMA barrier locations to CB index. |
| [`generate_signpost_name`](#ttl-_src-auto_profile-generate_signpost_name) | Generate before/after signpost names for an operation. |
| [`get_line_mapper`](#ttl-_src-auto_profile-get_line_mapper) | Get the global line mapper instance. |
| [`is_auto_profile_enabled`](#ttl-_src-auto_profile-is_auto_profile_enabled) | Check if auto-profiling is enabled via environment variable. |
| [`load_cb_flow_graph`](#ttl-_src-auto_profile-load_cb_flow_graph) | Load CB flow graph JSON from same directory as CSV. |
| [`parse_device_profile_csv`](#ttl-_src-auto_profile-parse_device_profile_csv) | Parse the device profile CSV and extract signpost timing data. |
| [`parse_signpost_name`](#ttl-_src-auto_profile-parse_signpost_name) | Parse op name and implicit flag from signpost name. |
| [`print_profile_report`](#ttl-_src-auto_profile-print_profile_report) | Print a profile report organized by thread. |

### Data

[`_global_line_mapper`](#ttl-_src-auto_profile-_global_line_mapper)

### API

<Anchor id="ttl-_src-auto_profile-Colors">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
class ttl._src.auto_profile.Colors()
```

</CodeBlock>
</Anchor>

<Indent>

ANSI color codes for terminal output.


<ParamField path="BOLD" type="= '\x1b[1m'">
</ParamField>

<ParamField path="CB_BACKGROUNDS">
</ParamField>

<ParamField path="CYAN" type="= '\x1b[96m'">
</ParamField>

<ParamField path="DIM" type="= '\x1b[2m'">
</ParamField>

<ParamField path="GREEN" type="= '\x1b[92m'">
</ParamField>

<ParamField path="RED" type="= '\x1b[91m'">
</ParamField>

<ParamField path="RESET" type="= '\x1b[0m'">
</ParamField>

<ParamField path="YELLOW" type="= '\x1b[93m'">
</ParamField>
<Anchor id="ttl-_src-auto_profile-Colors-cb_bg">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl._src.auto_profile.Colors.cb_bg(
    cb_index: int
) -> str
```

</CodeBlock>
</Anchor>

<Indent>

<Badge>classmethod</Badge>

Get background color for a CB index, or empty if out of range.


</Indent>
</Indent>

<Anchor id="ttl-_src-auto_profile-ProfileResult">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
class ttl._src.auto_profile.ProfileResult(
    signpost: str,
    thread: str,
    cycles: int,
    lineno: int,
    source: str
)
```

</CodeBlock>
</Anchor>

<Indent>

Represents profiling results for a single signpost.


<ParamField path="source" type="= source.strip()">
</ParamField>
</Indent>

<Anchor id="ttl-_src-auto_profile-SourceLineMapper">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
class ttl._src.auto_profile.SourceLineMapper()
```

</CodeBlock>
</Anchor>

<Indent>

Maps signpost markers back to source code lines.


<ParamField path="line_offset" type="int = 0">
</ParamField>

<ParamField path="signpost_to_line" type="Dict[str, Tuple[int, str]] = &#123;&#125;">
</ParamField>

<ParamField path="source_lines" type="List[str] = []">
</ParamField>
<Anchor id="ttl-_src-auto_profile-SourceLineMapper-get_line_info">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl._src.auto_profile.SourceLineMapper.get_line_info(
    signpost_name: str
) -> typing.Optional[typing.Tuple[int, str]]
```

</CodeBlock>
</Anchor>

<Indent>

Get line number and source for a signpost.


</Indent>
<Anchor id="ttl-_src-auto_profile-SourceLineMapper-register_signpost">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl._src.auto_profile.SourceLineMapper.register_signpost(
    signpost_name: str,
    lineno: int,
    source: str
)
```

</CodeBlock>
</Anchor>

<Indent>

Register a signpost with its source line information.


</Indent>
<Anchor id="ttl-_src-auto_profile-SourceLineMapper-set_source">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl._src.auto_profile.SourceLineMapper.set_source(
    source_lines: typing.List[str]
)
```

</CodeBlock>
</Anchor>

<Indent>

Set the source code lines for display.


</Indent>
</Indent>

<Anchor id="ttl-_src-auto_profile-build_cb_wait_to_dma_map">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl._src.auto_profile.build_cb_wait_to_dma_map(
    cb_flow: typing.Optional[typing.Dict]
) -> typing.Dict[typing.Tuple[str, int], typing.Tuple[str, int, int]]
```

</CodeBlock>
</Anchor>

<Indent>

Build mapping from cb_wait locations to DMA barrier locations.

Only maps consumers waiting for DMA reads (data flowing into CB).
cb_wait ops waiting for compute output (where DMA is a write) are not mapped.

**Returns:** `Dict[Tuple[str, int], Tuple[str, int, int]]`

Dict mapping (kernel, line) of cb_wait -&gt; (barrier_kernel, barrier_line, cb_index)


</Indent>

<Anchor id="ttl-_src-auto_profile-build_dma_producer_to_cb_map">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl._src.auto_profile.build_dma_producer_to_cb_map(
    cb_flow: typing.Optional[typing.Dict]
) -> typing.Dict[typing.Tuple[str, int], int]
```

</CodeBlock>
</Anchor>

<Indent>

Build mapping from DMA barrier locations to CB index.

**Returns:** `Dict[Tuple[str, int], int]`

Dict mapping (kernel, line) of DMA read barrier -&gt; cb_index


</Indent>

<Anchor id="ttl-_src-auto_profile-generate_signpost_name">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl._src.auto_profile.generate_signpost_name(
    operation: str,
    lineno: int,
    col: int
) -> typing.Tuple[str, str]
```

</CodeBlock>
</Anchor>

<Indent>

Generate before/after signpost names for an operation.

**Returns:** `Tuple[str, str]`

Tuple of (before_name, after_name)


</Indent>

<Anchor id="ttl-_src-auto_profile-get_line_mapper">

<CodeBlock links={{"ttl._src.auto_profile.SourceLineMapper":"#ttl-_src-auto_profile-SourceLineMapper"}} showLineNumbers={false} wordWrap={true}>

```python
ttl._src.auto_profile.get_line_mapper() -> ttl._src.auto_profile.SourceLineMapper
```

</CodeBlock>
</Anchor>

<Indent>

Get the global line mapper instance.


</Indent>

<Anchor id="ttl-_src-auto_profile-is_auto_profile_enabled">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl._src.auto_profile.is_auto_profile_enabled() -> bool
```

</CodeBlock>
</Anchor>

<Indent>

Check if auto-profiling is enabled via environment variable.


</Indent>

<Anchor id="ttl-_src-auto_profile-load_cb_flow_graph">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl._src.auto_profile.load_cb_flow_graph(
    csv_path: pathlib.Path
) -> typing.Optional[typing.Dict]
```

</CodeBlock>
</Anchor>

<Indent>

Load CB flow graph JSON from same directory as CSV.


</Indent>

<Anchor id="ttl-_src-auto_profile-parse_device_profile_csv">

<CodeBlock links={{"ttl._src.auto_profile.SourceLineMapper":"#ttl-_src-auto_profile-SourceLineMapper","ttl._src.auto_profile.ProfileResult":"#ttl-_src-auto_profile-ProfileResult"}} showLineNumbers={false} wordWrap={true}>

```python
ttl._src.auto_profile.parse_device_profile_csv(
    csv_path: pathlib.Path,
    line_mapper: ttl._src.auto_profile.SourceLineMapper
) -> typing.List[ttl._src.auto_profile.ProfileResult]
```

</CodeBlock>
</Anchor>

<Indent>

Parse the device profile CSV and extract signpost timing data.

**Parameters:**

<ParamField path="csv_path" type="Path">
Path to profile_log_device.csv
</ParamField>

<ParamField path="line_mapper" type="SourceLineMapper">
Mapper to correlate signposts to source lines
</ParamField>

**Returns:** `List[ProfileResult]`

List of ProfileResult objects sorted by line number


</Indent>

<Anchor id="ttl-_src-auto_profile-parse_signpost_name">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl._src.auto_profile.parse_signpost_name(
    signpost: str
) -> typing.Tuple[typing.Optional[str], bool]
```

</CodeBlock>
</Anchor>

<Indent>

Parse op name and implicit flag from signpost name.

Returns (op_name, is_implicit) where op_name is None for line-only signposts.
Examples:
  "line_52_before" -&gt; (None, False)
  "line_52_cb_wait_before" -&gt; ("cb_wait", False)
  "line_52_implicit_cb_pop_before" -&gt; ("cb_pop", True)


</Indent>

<Anchor id="ttl-_src-auto_profile-print_profile_report">

<CodeBlock links={{"ttl._src.auto_profile.ProfileResult":"#ttl-_src-auto_profile-ProfileResult","ttl._src.auto_profile.SourceLineMapper":"#ttl-_src-auto_profile-SourceLineMapper"}} showLineNumbers={false} wordWrap={true}>

```python
ttl._src.auto_profile.print_profile_report(
    results: typing.List[ttl._src.auto_profile.ProfileResult],
    all_source_lines: typing.Dict[str, typing.List[str]],
    thread_to_kernel: typing.Dict[str, str],
    line_mapper: typing.Optional[ttl._src.auto_profile.SourceLineMapper] = None,
    cb_wait_to_dma: typing.Optional[typing.Dict[typing.Tuple[str, int], typing.Tuple[str, int, int]]] = None,
    dma_producer_to_cb: typing.Optional[typing.Dict[typing.Tuple[str, int], int]] = None,
    kernel_line_offsets: typing.Optional[typing.Dict[str, int]] = None
)
```

</CodeBlock>
</Anchor>

<Indent>

Print a profile report organized by thread.

Shows full source context with cycle annotations where available.
Each thread displays its corresponding kernel's source code.

**Parameters:**

<ParamField path="results" type="List[ProfileResult]">
List of ProfileResult from CSV parsing
</ParamField>

<ParamField path="all_source_lines" type="Dict[str, List[str]]">
Dict mapping kernel name to source lines
</ParamField>

<ParamField path="thread_to_kernel" type="Dict[str, str]">
Dict mapping RISC thread name to kernel name
</ParamField>

<ParamField path="line_mapper" type="Optional[SourceLineMapper]" default="None">
Optional SourceLineMapper with line offset info
</ParamField>

<ParamField path="cb_wait_to_dma" type="Optional[Dict[Tuple[str, int], Tuple[str, int, int]]]" default="None">
Optional mapping from (kernel, line) -&gt; (dma_kernel, dma_line, cb_index)
</ParamField>

<ParamField path="dma_producer_to_cb" type="Optional[Dict[Tuple[str, int], int]]" default="None">
Optional mapping from (kernel, line) -&gt; cb_index for DMA producers
</ParamField>

<ParamField path="kernel_line_offsets" type="Optional[Dict[str, int]]" default="None">
Optional mapping from kernel name to line offset
</ParamField>


</Indent>

<Anchor id="ttl-_src-auto_profile-_global_line_mapper">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl._src.auto_profile._global_line_mapper = SourceLineMapper()
```

</CodeBlock>
</Anchor>

