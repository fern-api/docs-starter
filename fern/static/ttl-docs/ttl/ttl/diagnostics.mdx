---
layout: overview
slug: ttl/ttl/diagnostics
title: ttl.diagnostics
---

Diagnostic utilities for formatting compiler errors with source context.

This module provides Rust/Swift-style error formatting that displays
source code snippets with ASCII arrows pointing to the error location.

## Module Contents

### Classes

| Name | Description |
|------|-------------|
| [`SourceDiagnostic`](#ttl-diagnostics-SourceDiagnostic) | Format errors with source context and ASCII arrows. |
| [`TTLangCompileError`](#ttl-diagnostics-TTLangCompileError) | Exception for tt-lang compilation errors with source context. |

### Functions

| Name | Description |
|------|-------------|
| [`_extract_core_message`](#ttl-diagnostics-_extract_core_message) | Extract the core error message from MLIR diagnostic output. |
| [`_extract_note`](#ttl-diagnostics-_extract_note) | Extract any note from the MLIR error message. |
| [`_read_file_lines`](#ttl-diagnostics-_read_file_lines) | Read source lines from a file if it exists. |
| [`_verbose_errors_enabled`](#ttl-diagnostics-_verbose_errors_enabled) | Check if verbose MLIR error output is enabled. |
| [`extract_location_from_mlir_error`](#ttl-diagnostics-extract_location_from_mlir_error) | Extract source location from an MLIR error message. |
| [`find_variable_assignment`](#ttl-diagnostics-find_variable_assignment) | Find the line where a variable was assigned, searching backwards. |
| [`format_mlir_error`](#ttl-diagnostics-format_mlir_error) | Format an MLIR error with source context if location is available. |
| [`format_python_error`](#ttl-diagnostics-format_python_error) | Format a Python error with source context. |
| [`parse_mlir_location`](#ttl-diagnostics-parse_mlir_location) | Parse an MLIR location string to extract file, line, and column. |

### API

<Anchor id="ttl-diagnostics-SourceDiagnostic">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
class ttl.diagnostics.SourceDiagnostic(
    source_lines: typing.List[str],
    filename: str
)
```

</CodeBlock>
</Anchor>

<Indent>

Format errors with source context and ASCII arrows.

Produces error messages in the style of modern compilers (Rust, Swift):

    error: type mismatch in add operation
      --&gt; kernel.py:43:16
       |
    43 |         result = l + r
       |                  ^^^ expected bf16, got f32
       |


<Anchor id="ttl-diagnostics-SourceDiagnostic-format_error">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl.diagnostics.SourceDiagnostic.format_error(
    line: int,
    col: int,
    message: str,
    label: str = 'error',
    span_length: int = 1,
    note: typing.Optional[str] = None
) -> str
```

</CodeBlock>
</Anchor>

<Indent>

Format an error with source context.

**Parameters:**

<ParamField path="line" type="int">
1-based line number
</ParamField>

<ParamField path="col" type="int">
1-based column number
</ParamField>

<ParamField path="message" type="str">
Main error message
</ParamField>

<ParamField path="label" type="str" default="'error'">
Error label (e.g., "error", "warning")
</ParamField>

<ParamField path="span_length" type="int" default="1">
Length of the underline (^^^)
</ParamField>

<ParamField path="note" type="Optional[str]" default="None">
Optional additional note
</ParamField>

**Returns:** `str`

Formatted error string with source context


</Indent>
<Anchor id="ttl-diagnostics-SourceDiagnostic-format_error_chain">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl.diagnostics.SourceDiagnostic.format_error_chain(
    errors: typing.List[typing.Tuple[int, int, str, typing.Optional[str]]]
) -> str
```

</CodeBlock>
</Anchor>

<Indent>

Format multiple related errors.

**Parameters:**

<ParamField path="errors" type="List[Tuple[int, int, str, Optional[str]]]">
List of (line, col, message, note) tuples
</ParamField>

**Returns:** `str`

Formatted error chain


</Indent>
</Indent>

<Anchor id="ttl-diagnostics-TTLangCompileError">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
class ttl.diagnostics.TTLangCompileError(
    message: str,
    source_file: typing.Optional[str] = None,
    line: typing.Optional[int] = None,
    col: typing.Optional[int] = None,
    source_lines: typing.Optional[typing.List[str]] = None
)
```

</CodeBlock>
</Anchor>

<Indent>

<Badge>Exception</Badge>

**Bases:** `Exception`

Exception for tt-lang compilation errors with source context.

This exception carries enough information to produce pretty error messages
pointing to the exact source location where the error occurred.


<Anchor id="ttl-diagnostics-TTLangCompileError-format">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl.diagnostics.TTLangCompileError.format() -> str
```

</CodeBlock>
</Anchor>

<Indent>

Format error with source context if available.


</Indent>
</Indent>

<Anchor id="ttl-diagnostics-_extract_core_message">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl.diagnostics._extract_core_message(
    error_msg: str
) -> str
```

</CodeBlock>
</Anchor>

<Indent>

Extract the core error message from MLIR diagnostic output.

This extracts: "expects transfer handle to be synchronized with ttl.wait"


</Indent>

<Anchor id="ttl-diagnostics-_extract_note">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl.diagnostics._extract_note(
    error_msg: str
) -> typing.Optional[str]
```

</CodeBlock>
</Anchor>

<Indent>

Extract any note from the MLIR error message.


</Indent>

<Anchor id="ttl-diagnostics-_read_file_lines">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl.diagnostics._read_file_lines(
    filepath: str
) -> typing.Optional[typing.List[str]]
```

</CodeBlock>
</Anchor>

<Indent>

Read source lines from a file if it exists.


</Indent>

<Anchor id="ttl-diagnostics-_verbose_errors_enabled">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl.diagnostics._verbose_errors_enabled() -> bool
```

</CodeBlock>
</Anchor>

<Indent>

Check if verbose MLIR error output is enabled.


</Indent>

<Anchor id="ttl-diagnostics-extract_location_from_mlir_error">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl.diagnostics.extract_location_from_mlir_error(
    error_msg: str
) -> typing.Optional[typing.Tuple[str, int, int]]
```

</CodeBlock>
</Anchor>

<Indent>

Extract source location from an MLIR error message.

**Parameters:**

<ParamField path="error_msg" type="str">
Full MLIR error message
</ParamField>

**Returns:** `Optional[Tuple[str, int, int]]`

Tuple of (filename, line, col) or None if no location found


</Indent>

<Anchor id="ttl-diagnostics-find_variable_assignment">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl.diagnostics.find_variable_assignment(
    source_lines: typing.List[str],
    var_name: str,
    before_line: int
) -> typing.Optional[int]
```

</CodeBlock>
</Anchor>

<Indent>

Find the line where a variable was assigned, searching backwards.

**Parameters:**

<ParamField path="source_lines" type="List[str]">
List of source lines (0-indexed)
</ParamField>

<ParamField path="var_name" type="str">
Variable name to search for
</ParamField>

<ParamField path="before_line" type="int">
Search backwards from this 1-based line number
</ParamField>

**Returns:** `Optional[int]`

1-based line number where assignment was found, or None


</Indent>

<Anchor id="ttl-diagnostics-format_mlir_error">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl.diagnostics.format_mlir_error(
    error_msg: str,
    source_lines: typing.Optional[typing.List[str]] = None,
    source_file: typing.Optional[str] = None
) -> str
```

</CodeBlock>
</Anchor>

<Indent>

Format an MLIR error with source context if location is available.

**Parameters:**

<ParamField path="error_msg" type="str">
The MLIR error message
</ParamField>

<ParamField path="source_lines" type="Optional[List[str]]" default="None">
Original Python source lines (optional, will read from file if needed)
</ParamField>

<ParamField path="source_file" type="Optional[str]" default="None">
Source filename (optional, extracted from error if not provided)
</ParamField>

**Returns:** `str`

Formatted error message, with source context if available


</Indent>

<Anchor id="ttl-diagnostics-format_python_error">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl.diagnostics.format_python_error(
    error: Exception,
    source_file: str,
    line: int,
    source_lines: typing.Optional[typing.List[str]] = None
) -> str
```

</CodeBlock>
</Anchor>

<Indent>

Format a Python error with source context.

**Parameters:**

<ParamField path="error" type="Exception">
The Python exception
</ParamField>

<ParamField path="source_file" type="str">
Source file path
</ParamField>

<ParamField path="line" type="int">
Line number in source file
</ParamField>

<ParamField path="source_lines" type="Optional[List[str]]" default="None">
Source lines (will read from file if not provided)
</ParamField>

**Returns:** `str`

Formatted error message with source context


</Indent>

<Anchor id="ttl-diagnostics-parse_mlir_location">

<CodeBlock showLineNumbers={false} wordWrap={true}>

```python
ttl.diagnostics.parse_mlir_location(
    loc_str: str
) -> typing.Optional[typing.Tuple[str, int, int]]
```

</CodeBlock>
</Anchor>

<Indent>

Parse an MLIR location string to extract file, line, and column.

MLIR locations can appear in several formats:
- loc("filename":line:col)
- loc("filename":line:col to :line:col)
- loc(#loc1) with #loc1 = loc("filename":line:col)

**Parameters:**

<ParamField path="loc_str" type="str">
MLIR location string
</ParamField>

**Returns:** `Optional[Tuple[str, int, int]]`

Tuple of (filename, line, col) or None if not parseable


</Indent>
